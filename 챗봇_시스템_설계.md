# 🤖 수요 예측 챗봇 시스템 설계

## 🎯 전체 시스템 구조

```
┌─────────────────────────────────────────────────────────────┐
│                    사용자 웹 인터페이스                      │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  [1단계] CSV 업로드                                          │
│  - 파일 선택 및 업로드                                       │
│  - MongoDB에 저장 (files, csv_contents)                     │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  [2단계] 자동 분석 및 예측                                    │
│  - 피처 엔지니어링 (auto_feature_pipeline)                  │
│  - 수량 예측 모델 학습                                       │
│  - 금액 예측 모델 학습                                       │
│  - 결과 저장 (analysis_results, feature_weights)            │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  [3단계] 시각화 생성                                         │
│  - 예측 결과 차트 (Plotly/Chart.js)                         │
│  - 트렌드 분석 그래프                                        │
│  - 피처 중요도 시각화                                        │
│  - 이미지로 저장 또는 Base64 인코딩                          │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│  [4단계] LLM 챗봇 해석                                       │
│  - 예측 결과 + 시각화 데이터를 LLM에 전달                    │
│  - LLM이 인사이트 생성 및 설명                              │
│  - 사용자 질문에 답변 (채팅 형식)                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 📊 데이터 흐름

### 1. CSV 업로드 → 분석
```
CSV 파일
  ↓
MongoDB 저장 (files, csv_contents)
  ↓
자동화 파이프라인 실행
  ├─ 수량 예측 모델
  └─ 금액 예측 모델
  ↓
예측 결과 저장 (analysis_results)
```

### 2. 예측 결과 → 시각화
```
예측 결과
  ├─ 수량 예측값
  ├─ 금액 예측값
  ├─ 모델 성능 지표
  └─ 피처 중요도
  ↓
시각화 생성
  ├─ 시계열 차트 (실제 vs 예측)
  ├─ 피처 중요도 바 차트
  └─ 성능 지표 대시보드
  ↓
이미지 저장 또는 Base64
```

### 3. 시각화 + 예측 결과 → LLM
```
예측 결과 (JSON)
  + 시각화 이미지 (Base64)
  + 사용자 질문
  ↓
LLM 프롬프트 생성
  ↓
LLM 응답 (인사이트 + 설명)
  ↓
챗봇 UI에 표시
```

---

## 🗄️ MongoDB 컬렉션 추가

### `predictions` 컬렉션 (신규)
```json
{
  "_id": ObjectId("..."),
  "prediction_id": "pred_20241229120000",
  "file_id": "file_001",
  "user_id": "user123",
  "predictions": {
    "quantity": [                    // 수량 예측값
      {"date": "2024-12-30", "predicted": 10.5, "actual": null},
      {"date": "2024-12-31", "predicted": 12.3, "actual": null}
    ],
    "amount": [                     // 금액 예측값
      {"date": "2024-12-30", "predicted": 15000, "actual": null},
      {"date": "2024-12-31", "predicted": 18000, "actual": null}
    ]
  },
  "model_metrics": {
    "quantity": {"mae": 1.23, "r2": 0.65, "accuracy": 72.5},
    "amount": {"mae": 500.5, "r2": 0.70, "accuracy": 75.0}
  },
  "created_at": ISODate("2024-12-29T12:00:00Z")
}
```

### `visualizations` 컬렉션 (신규)
```json
{
  "_id": ObjectId("..."),
  "viz_id": "viz_20241229120000",
  "file_id": "file_001",
  "user_id": "user123",
  "charts": {
    "quantity_forecast": "base64_encoded_image...",  // 수량 예측 차트
    "amount_forecast": "base64_encoded_image...",     // 금액 예측 차트
    "feature_importance": "base64_encoded_image...",  // 피처 중요도
    "performance_dashboard": "base64_encoded_image..." // 성능 대시보드
  },
  "chart_data": {                    // 차트 데이터 (JSON)
    "quantity_forecast": {
      "dates": ["2024-12-30", "2024-12-31"],
      "predicted": [10.5, 12.3],
      "actual": [null, null]
    }
  },
  "created_at": ISODate("2024-12-29T12:00:00Z")
}
```

### `chat_history` 컬렉션 (신규)
```json
{
  "_id": ObjectId("..."),
  "chat_id": "chat_20241229120000",
  "file_id": "file_001",
  "user_id": "user123",
  "messages": [
    {
      "role": "user",
      "content": "이번 주 수량 예측이 어떻게 되나요?",
      "timestamp": ISODate("2024-12-29T12:00:00Z")
    },
    {
      "role": "assistant",
      "content": "이번 주 수량 예측은 평균 10.5개로 예상됩니다...",
      "timestamp": ISODate("2024-12-29T12:00:01Z"),
      "insights": ["수량이 전주 대비 5% 증가 예상", "주말에 판매량 증가"]
    }
  ],
  "created_at": ISODate("2024-12-29T12:00:00Z")
}
```

---

## 💻 구현 코드 구조

### 1. 예측 모델 (수량 + 금액)

```python
# prediction_service.py
class PredictionService:
    def predict_quantity_and_amount(self, file_id, forecast_days=7):
        """
        수량과 금액을 동시에 예측
        """
        # 1. 데이터 로드
        data = self.load_data_from_mongodb(file_id)
        
        # 2. 피처 엔지니어링
        pipeline = AutoFeaturePipeline(target_column="수량")
        processed_data = pipeline.auto_feature_engineering(data)
        
        # 3. 수량 예측 모델
        quantity_model, quantity_metrics = pipeline.train_model(
            processed_data, 
            feature_columns, 
            target_column="수량"
        )
        
        # 4. 금액 예측 모델
        pipeline_amount = AutoFeaturePipeline(target_column="금액")
        amount_model, amount_metrics = pipeline_amount.train_model(
            processed_data,
            feature_columns,
            target_column="금액"
        )
        
        # 5. 미래 예측
        quantity_forecast = self.forecast_future(
            quantity_model, processed_data, forecast_days
        )
        amount_forecast = self.forecast_future(
            amount_model, processed_data, forecast_days
        )
        
        # 6. 결과 저장
        self.save_predictions(file_id, quantity_forecast, amount_forecast)
        
        return {
            "quantity": quantity_forecast,
            "amount": amount_forecast,
            "metrics": {
                "quantity": quantity_metrics,
                "amount": amount_metrics
            }
        }
```

### 2. 시각화 생성

```python
# visualization_service.py
class VisualizationService:
    def create_forecast_charts(self, predictions, file_id):
        """
        예측 결과를 시각화
        """
        import plotly.graph_objects as go
        import base64
        from io import BytesIO
        
        charts = {}
        
        # 1. 수량 예측 차트
        fig_quantity = go.Figure()
        fig_quantity.add_trace(go.Scatter(
            x=predictions['quantity']['dates'],
            y=predictions['quantity']['predicted'],
            name='예측 수량',
            line=dict(color='blue')
        ))
        fig_quantity.update_layout(
            title='수량 예측',
            xaxis_title='날짜',
            yaxis_title='수량'
        )
        
        # 이미지로 변환 (Base64)
        img_buffer = BytesIO()
        fig_quantity.write_image(img_buffer, format='png')
        img_base64 = base64.b64encode(img_buffer.getvalue()).decode()
        charts['quantity_forecast'] = img_base64
        
        # 2. 금액 예측 차트
        fig_amount = go.Figure()
        fig_amount.add_trace(go.Scatter(
            x=predictions['amount']['dates'],
            y=predictions['amount']['predicted'],
            name='예측 금액',
            line=dict(color='green')
        ))
        fig_amount.update_layout(
            title='금액 예측',
            xaxis_title='날짜',
            yaxis_title='금액'
        )
        
        img_buffer = BytesIO()
        fig_amount.write_image(img_buffer, format='png')
        img_base64 = base64.b64encode(img_buffer.getvalue()).decode()
        charts['amount_forecast'] = img_base64
        
        # 3. MongoDB에 저장
        self.save_visualizations(file_id, charts, predictions)
        
        return charts
```

### 3. LLM 챗봇 서비스

```python
# llm_chatbot_service.py
from openai import OpenAI
# 또는 다른 LLM API (Claude, Gemini 등)

class LLMChatbotService:
    def __init__(self, api_key):
        self.client = OpenAI(api_key=api_key)
        # 또는 Anthropic, Google 등
    
    def generate_insights(self, predictions, visualizations, metrics):
        """
        예측 결과를 LLM이 해석하여 인사이트 생성
        """
        # 프롬프트 생성
        prompt = f"""
        다음은 수요 예측 분석 결과입니다:
        
        [수량 예측]
        - 평균 예측 수량: {predictions['quantity']['avg']}개
        - 예측 정확도: {metrics['quantity']['accuracy']}%
        - MAE: {metrics['quantity']['mae']}
        
        [금액 예측]
        - 평균 예측 금액: {predictions['amount']['avg']}원
        - 예측 정확도: {metrics['amount']['accuracy']}%
        - MAE: {metrics['amount']['mae']}
        
        [주요 피처]
        {self.format_feature_importance(metrics)}
        
        위 결과를 바탕으로:
        1. 주요 인사이트 3가지를 요약해주세요
        2. 비즈니스 관점에서 어떤 의미인지 설명해주세요
        3. 개선 방안을 제시해주세요
        
        한국어로 친절하게 설명해주세요.
        """
        
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "당신은 데이터 분석 전문가입니다."},
                {"role": "user", "content": prompt}
            ]
        )
        
        return response.choices[0].message.content
    
    def answer_question(self, question, predictions, visualizations, chat_history):
        """
        사용자 질문에 답변
        """
        # 컨텍스트 구성
        context = f"""
        [예측 결과]
        {json.dumps(predictions, ensure_ascii=False, indent=2)}
        
        [이전 대화]
        {self.format_chat_history(chat_history)}
        
        [사용자 질문]
        {question}
        
        위 정보를 바탕으로 사용자의 질문에 답변해주세요.
        한국어로 친절하고 전문적으로 설명해주세요.
        """
        
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "당신은 수요 예측 분석 챗봇입니다."},
                {"role": "user", "content": context}
            ]
        )
        
        return response.choices[0].message.content
```

### 4. 웹 API 통합

```python
# web_api.py (Flask/FastAPI)
from flask import Flask, request, jsonify
from prediction_service import PredictionService
from visualization_service import VisualizationService
from llm_chatbot_service import LLMChatbotService

app = Flask(__name__)

prediction_service = PredictionService()
viz_service = VisualizationService()
llm_service = LLMChatbotService(api_key="your-api-key")

@app.route('/api/analyze-and-predict', methods=['POST'])
def analyze_and_predict():
    """
    CSV 분석 → 예측 → 시각화 → LLM 인사이트 생성
    """
    data = request.json
    file_id = data['file_id']
    forecast_days = data.get('forecast_days', 7)
    
    # 1. 예측
    predictions = prediction_service.predict_quantity_and_amount(
        file_id, forecast_days
    )
    
    # 2. 시각화
    charts = viz_service.create_forecast_charts(predictions, file_id)
    
    # 3. LLM 인사이트
    insights = llm_service.generate_insights(
        predictions, charts, predictions['metrics']
    )
    
    return jsonify({
        'predictions': predictions,
        'charts': charts,
        'insights': insights
    })

@app.route('/api/chat', methods=['POST'])
def chat():
    """
    챗봇 대화
    """
    data = request.json
    file_id = data['file_id']
    question = data['question']
    user_id = data['user_id']
    
    # 예측 결과 및 시각화 로드
    predictions = prediction_service.get_predictions(file_id)
    visualizations = viz_service.get_visualizations(file_id)
    chat_history = llm_service.get_chat_history(file_id, user_id)
    
    # LLM 답변
    answer = llm_service.answer_question(
        question, predictions, visualizations, chat_history
    )
    
    # 대화 저장
    llm_service.save_message(file_id, user_id, question, answer)
    
    return jsonify({
        'answer': answer,
        'insights': llm_service.extract_insights(answer)
    })
```

---

## 🎨 프론트엔드 UI 구조

### React/Vue 컴포넌트 예시

```javascript
// ChatbotComponent.jsx
import React, { useState } from 'react';
import { Line } from 'react-chartjs-2';

function ChatbotComponent({ fileId }) {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [predictions, setPredictions] = useState(null);
  const [charts, setCharts] = useState(null);
  
  // 분석 및 예측 실행
  const handleAnalyze = async () => {
    const response = await fetch('/api/analyze-and-predict', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ file_id: fileId, forecast_days: 7 })
    });
    
    const data = await response.json();
    setPredictions(data.predictions);
    setCharts(data.charts);
    
    // LLM 인사이트를 첫 메시지로 추가
    setMessages([{
      role: 'assistant',
      content: data.insights
    }]);
  };
  
  // 챗봇 질문
  const handleSend = async () => {
    // 사용자 메시지 추가
    setMessages([...messages, { role: 'user', content: input }]);
    
    // LLM 답변 요청
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        file_id: fileId,
        question: input,
        user_id: 'user123'
      })
    });
    
    const data = await response.json();
    setMessages([...messages, 
      { role: 'user', content: input },
      { role: 'assistant', content: data.answer }
    ]);
    
    setInput('');
  };
  
  return (
    <div className="chatbot-container">
      {/* 시각화 영역 */}
      <div className="visualization-area">
        {charts && (
          <>
            <img src={`data:image/png;base64,${charts.quantity_forecast}`} />
            <img src={`data:image/png;base64,${charts.amount_forecast}`} />
          </>
        )}
      </div>
      
      {/* 챗봇 영역 */}
      <div className="chat-area">
        <div className="messages">
          {messages.map((msg, idx) => (
            <div key={idx} className={`message ${msg.role}`}>
              {msg.content}
            </div>
          ))}
        </div>
        
        <div className="input-area">
          <input 
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="질문을 입력하세요..."
          />
          <button onClick={handleSend}>전송</button>
        </div>
      </div>
    </div>
  );
}
```

---

## 🔄 전체 플로우 예시

### 사용자 시나리오

```
[1] 사용자가 CSV 업로드
    → "sales_data.csv" 업로드

[2] "분석 시작" 버튼 클릭
    → 백엔드에서 자동 분석 및 예측 실행
    → 수량 예측: 평균 10.5개/일
    → 금액 예측: 평균 15,000원/일

[3] 시각화 자동 생성
    → 수량 예측 차트 표시
    → 금액 예측 차트 표시

[4] LLM이 자동으로 인사이트 생성
    챗봇: "안녕하세요! 분석 결과를 요약해드리겠습니다.
           이번 주 수량 예측은 평균 10.5개로, 전주 대비 5% 증가 예상됩니다.
           금액 예측은 평균 15,000원으로, 수량 증가에 비해 금액 증가율이 낮아
           단가 하락 가능성이 있습니다. 주말에 판매량이 증가하는 패턴이 보이므로
           재고 준비를 권장합니다."

[5] 사용자가 질문
    사용자: "주말에 왜 판매량이 증가하나요?"
    
    챗봇: "과거 데이터를 분석한 결과, 토요일과 일요일의 평균 판매량이
           평일 대비 약 15% 높게 나타났습니다. 이는 주말 쇼핑 트렌드와
           관련이 있을 것으로 보입니다. 또한 기온이 높을수록 판매량이
           증가하는 경향이 있어, 주말 날씨가 좋으면 더욱 증가할 가능성이
           있습니다."

[6] 추가 질문
    사용자: "재고는 얼마나 준비해야 하나요?"
    
    챗봇: "예측 모델에 따르면, 이번 주말(12월 30-31일) 예상 수량은
           각각 12.3개, 13.5개입니다. 안전재고를 고려하면 최소 15-20개
           정도 준비하시는 것을 권장합니다. 현재 재고가 10개라면
           추가 주문이 필요할 수 있습니다."
```

---

## 📦 필요한 라이브러리

### Python 백엔드
```bash
pip install pandas numpy scikit-learn
pip install pymongo
pip install plotly kaleido  # 시각화
pip install openai  # 또는 anthropic, google-generativeai
pip install flask fastapi  # 웹 프레임워크
```

### 프론트엔드
```bash
npm install react react-chartjs-2 chart.js
npm install axios  # API 호출
```

---

## 🚀 구현 순서

1. **예측 서비스 구현** (`prediction_service.py`)
   - 수량/금액 예측 모델
   - 미래 예측 함수

2. **시각화 서비스 구현** (`visualization_service.py`)
   - Plotly로 차트 생성
   - Base64 인코딩

3. **LLM 챗봇 서비스 구현** (`llm_chatbot_service.py`)
   - OpenAI/Claude API 연동
   - 프롬프트 엔지니어링

4. **웹 API 구현** (`web_api.py`)
   - 분석/예측 엔드포인트
   - 챗봇 엔드포인트

5. **프론트엔드 구현**
   - 시각화 컴포넌트
   - 챗봇 UI

---

*문서 작성일: 2024-12-29*

